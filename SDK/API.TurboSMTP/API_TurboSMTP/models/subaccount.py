# coding: utf-8

"""
    TurboSMTP Public APIs

    This document describes all public turboSMTP **V2** API and offers endpoints Descriptions, Parameters, Requests, Responses and Samples of usage.  [Click here to view the previous version of turboSMTP Public API Version 1.0](https://www.serversmtp.com/turbo-api-1)   # Security For the most part (and where not otherwise explicit) turboSMTP’s API requires Authorization.   Authorization to access a user’s resource is granted to clients provided they set  authentication headers into their request, valued with the proper values issued by turboSMTP servers.  ## *  Authorization via ConsumerKey/ConsumerSecret  This type of authorization consists of a pair of headers, named consumerKey and consumerSecret that are created and granted to the end user to be used in a permanent way (unless they´re deleted of course). This kind of authentication is intended to provide access to endpoints features without the need of providing the user the account details (email address + password).  *consumerKey:* Consumer Key Granted.  *consumerSecret:* Consumer Secret Granted.  (Use [/consumerKeys/create](#/consumerkey/createConsumerKey) create a consumer key/secret pair).      ## *  Authorization via Authentication Key  The authentication key is user-based and it is issued by turboSMTP servers upon successful user’s email address + password challenge, performed by means of appropriate request.      *Authorization:* Authorization_Key  (Use [/authentication/authorize](#/authentication/AuthenticationLogin) to obtain an API Key)  # Data Interchange Format  For the most part (and where not otherwise explicit) turboSMTP’s API uses JSON as the data format of choice when it comes to request and response bodies.       

    The version of the OpenAPI document: 2.0.0-oas3
    Contact: api@turbo-smtp.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class Subaccount(BaseModel):
    """
    Subaccount
    """ # noqa: E501
    email: StrictStr
    ip: Optional[StrictStr] = Field(default=None, description="IP address to use for sending emails.")
    active: StrictBool = Field(description="Active subaccounts can be used for login purpose, while users can´t login to inactive subaccounts. Notice that in order to be able to send emails the subaccount subscription must also be active. User can set subaccounts to active / inactive from the dashboard.")
    subaccount_id: Optional[StrictInt] = Field(default=None, description="Sub account Id")
    parent_id: Optional[StrictInt] = Field(default=None, description="Sub account parent Id")
    first_name: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=50)]] = Field(default=None, description="subaccount owner first name")
    last_name: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=50)]] = Field(default=None, description="subaccount owner last name")
    address_1: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]] = Field(default=None, description="Address Line 1")
    address_2: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=255)]] = Field(default=None, description="Address Line 2")
    city: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=100)]] = Field(default=None, description="City")
    company_name: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=100)]] = Field(default=None, description="Agency Name")
    country: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=64)]] = Field(default=None, description="Country")
    region: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=100)]] = Field(default=None, description="Region")
    zip_code: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=10)]] = Field(default=None, description="Zip Code")
    phone_number: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=30)]] = Field(default=None, description="Phone Number")
    policy_agree: Optional[StrictBool] = Field(default=None, description="Policy must be agreed in order to be able to create a subaccount.")
    site_url: Optional[Annotated[str, Field(min_length=1, strict=True, max_length=45)]] = Field(default=None, description="Website")
    __properties: ClassVar[List[str]] = ["email", "ip", "active", "subaccount_id", "parent_id", "first_name", "last_name", "address_1", "address_2", "city", "company_name", "country", "region", "zip_code", "phone_number", "policy_agree", "site_url"]

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Subaccount from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if address_1 (nullable) is None
        # and model_fields_set contains the field
        if self.address_1 is None and "address_1" in self.model_fields_set:
            _dict['address_1'] = None

        # set to None if address_2 (nullable) is None
        # and model_fields_set contains the field
        if self.address_2 is None and "address_2" in self.model_fields_set:
            _dict['address_2'] = None

        # set to None if city (nullable) is None
        # and model_fields_set contains the field
        if self.city is None and "city" in self.model_fields_set:
            _dict['city'] = None

        # set to None if company_name (nullable) is None
        # and model_fields_set contains the field
        if self.company_name is None and "company_name" in self.model_fields_set:
            _dict['company_name'] = None

        # set to None if country (nullable) is None
        # and model_fields_set contains the field
        if self.country is None and "country" in self.model_fields_set:
            _dict['country'] = None

        # set to None if region (nullable) is None
        # and model_fields_set contains the field
        if self.region is None and "region" in self.model_fields_set:
            _dict['region'] = None

        # set to None if zip_code (nullable) is None
        # and model_fields_set contains the field
        if self.zip_code is None and "zip_code" in self.model_fields_set:
            _dict['zip_code'] = None

        # set to None if phone_number (nullable) is None
        # and model_fields_set contains the field
        if self.phone_number is None and "phone_number" in self.model_fields_set:
            _dict['phone_number'] = None

        # set to None if site_url (nullable) is None
        # and model_fields_set contains the field
        if self.site_url is None and "site_url" in self.model_fields_set:
            _dict['site_url'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Subaccount from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "email": obj.get("email"),
            "ip": obj.get("ip"),
            "active": obj.get("active"),
            "subaccount_id": obj.get("subaccount_id"),
            "parent_id": obj.get("parent_id"),
            "first_name": obj.get("first_name"),
            "last_name": obj.get("last_name"),
            "address_1": obj.get("address_1"),
            "address_2": obj.get("address_2"),
            "city": obj.get("city"),
            "company_name": obj.get("company_name"),
            "country": obj.get("country"),
            "region": obj.get("region"),
            "zip_code": obj.get("zip_code"),
            "phone_number": obj.get("phone_number"),
            "policy_agree": obj.get("policy_agree"),
            "site_url": obj.get("site_url")
        })
        return _obj


