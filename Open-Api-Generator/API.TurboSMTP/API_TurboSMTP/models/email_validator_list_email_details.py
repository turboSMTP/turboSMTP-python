# coding: utf-8

"""
    TurboSMTP Public APIs

    This document describes all public turboSMTP **V2** API and offers endpoints Descriptions, Parameters, Requests, Responses and Samples of usage.  [Click here to view the previous version of turboSMTP Public API Version 1.0](https://www.serversmtp.com/turbo-api-1)   # Security For the most part (and where not otherwise explicit) turboSMTP’s API requires Authorization.   Authorization to access a user’s resource is granted to clients provided they set  authentication headers into their request, valued with the proper values issued by turboSMTP servers.  ## *  Authorization via ConsumerKey/ConsumerSecret  This type of authorization consists of a pair of headers, named consumerKey and consumerSecret that are created and granted to the end user to be used in a permanent way (unless they´re deleted of course). This kind of authentication is intended to provide access to endpoints features without the need of providing the user the account details (email address + password).  *consumerKey:* Consumer Key Granted.  *consumerSecret:* Consumer Secret Granted.  (Use [/consumerKeys/create](#/consumerkey/createConsumerKey) create a consumer key/secret pair).      ## *  Authorization via Authentication Key  The authentication key is user-based and it is issued by turboSMTP servers upon successful user’s email address + password challenge, performed by means of appropriate request.      *Authorization:* Authorization_Key  (Use [/authentication/authorize](#/authentication/AuthenticationLogin) to obtain an API Key)  # Data Interchange Format  For the most part (and where not otherwise explicit) turboSMTP’s API uses JSON as the data format of choice when it comes to request and response bodies.       

    The version of the OpenAPI document: 2.0.0-oas3
    Contact: api@turbo-smtp.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from typing import Optional, Set
from typing_extensions import Self

class EmailValidatorListEmailDetails(BaseModel):
    """
    EmailValidatorListEmailDetails
    """ # noqa: E501
    email: StrictStr
    status: Optional[StrictStr] = Field(default=None, description=" The status of the email address you are validating.    DELIVERABILITY STATUS EXPLANATION    valid:   These are emails that were determined to be valid and safe to email to, they will have a very low bounce rate of under 2%. If you receive bounces it can be because your IP might be blacklisted where our IP was not. Sometimes the email accounts exist, but they are only accepting mail from people in their contact lists. Sometimes you will get throttle on number of emails you can send to a specific domain per hour. It's important to look at the SMTP Bounce codes to determine why.      invalid:   These are emails that were determined to be invalid, please delete them from your mailing list.      catch-all:    These emails are impossible to validate without sending a real email and waiting for a bounce. The term Catch-all means that the email server tells you that the email is valid, whether it's valid or invalid. If you want to email these addresses, we suggest you segment them into a catch-all group and be aware that some of these will most likely bounce.      spamtrap:    These emails are believed to be spamtraps and should not be mailed. We have technology in place to determine if certain emails should be classified as spamtrap. We don't know all the spamtrap email addresses, but we do know a lot of them.      abuse:    These emails belong to people who are known to click the abuse links in emails, hence abusers or complainers. We recommend not emailing these addresses.      do_not_mail:    These emails belong to companies, role-based, or people you just want to avoid emailing to. They are broken down into 6 sub-categories \"disposable\",\"toxic\", \"role_based\", \"role_based_catch_all\", \"global_suppression\" and \"possible_trap\". You should decide if you want to email these address. They are valid email addresses, but shouldn't be mailed in most cases.      unknown:    These emails we weren't able to validate for one reason or another. Typical cases are \"Their mail server was down\" or \"the anti-spam system is blocking us\". In most cases, 80% unknowns are invalid/bad email addresses. ")
    sub_status: Optional[StrictStr] = Field(default=None, description="The sub-status of the email address you are validating.  alias_address:  (valid) These emails addresses act as forwarders/aliases and are not real inboxes, for example if you send an email to forward@example.com and then the email is forwarded to realinbox@example.com. It's a valid email address and you can send to them, it's just a little more information about the email address. We can sometimes detect alias email addresses and when we do we let you know.  antispam_system:  (unknown) These emails have anti-spam systems deployed that are preventing us from validating these emails.  does_not_accept_mail:  (invalid) These domains only send mail and don't accept incoming mail.  exception_occurred:  (unknown) These emails caused an exception when validating.  failed_smtp_connection:  (unknown) These emails belong to a mail server that won't allow an SMTP connection. Most of the time, these emails will end up being invalid.  failed_syntax_check:  (Invalid) Emails that fail RFC syntax protocols  forcible_disconnect:  (Unknown) These emails belong to a mail server that disconnects immediately upon connecting. Most of the time, these emails will end up being invalid. global_suppression:  (do_not_mail) These emails are found in many popular global suppression lists (GSL), they consist of known ISP complainers, direct complainers, purchased addresses, domains that don't send mail, and known litigators.  greylisted:  (Unknown) Emails where we are temporarily unable to validate them. A lot of times if you resubmit these emails they will validate on a second pass.  leading_period_removed:  (valid) If a valid gmail.com email address starts with a period '.' we will remove it, so the email address is compatible with all mailing systems.  mail_server_did_not_respond-  (unknown) These emails belong to a mail server that is not responding to mail commands. Most of the time, these emails will end up being invalid.  mail_server_temporary_error:  (unknown) These emails belong to a mail server that is returning a temporary error. Most of the time, these emails will end up being invalid. mailbox_quota_exceeded:  (invalid) These emails exceeded their space quota and are not accepting emails. These emails are marked invalid.  mailbox_not_found:  (invalid) These emails addresses are valid in syntax, but do not exist. These emails are marked invalid.  no_dns_entries:  (invalid) These emails are valid in syntax, but the domain doesn't have any records in DNS or have incomplete DNS Records. Therefore, mail programs will be unable to or have difficulty sending to them. These emails are marked invalid.  possible_trap:  (do_not_mail) These emails contain keywords that might correlate to possible spam traps like spam@ or @spamtrap.com. Examine these before deciding to send emails to them or not.  possible_typo:  (invalid) These are emails of commonly misspelled popular domains. These emails are marked invalid.  role_based:  (do_not_mail) These emails belong to a position or a group of people, like sales@ info@ and contact@. Role-based emails have a strong correlation to people reporting mails sent to them as spam and abuse.  role_based_catch_all:  (do_not_mail) These emails are role-based and also belong to a catch_all domain.  timeout_exceeded:  (unknown) These emails belong to a mail server that is responding extremely slow. Most of the time, these emails will end up being invalid.  unroutable_ip_address: (invalid) These emails domains point to an un-routable IP address, these are marked invalid.  disposable:  (do_not_mail) These are temporary emails created for the sole purpose to sign up to websites without giving their real email address. These emails are short lived from 15 minutes to around 6 months. There is only 2 values (True and False). If you have valid emails with this flag set to TRUE, you shouldn't email them.  toxic:  (do_not_mail) These email addresses are known to be abuse, spam, or bot created emails. If you have valid emails with this flag set to TRUE, you shouldn't email them. ")
    free_email: Optional[StrictBool] = Field(default=None, description="True if the email address comes from a free email service provider.")
    domain: Optional[StrictStr] = Field(default=None, description="The portion of the email address after the \"@\" symbol.")
    domain_age_days: Optional[StrictInt] = Field(default=None, description="Age of the email domain in days or [null].")
    smtp_provider: Optional[StrictStr] = Field(default=None, description="The SMTP Provider of the email or [null].")
    mx_found: Optional[StrictBool] = Field(default=None, description="True if the domain have an MX record.")
    mx_record: Optional[StrictStr] = Field(default=None, description="The preferred MX record of the domain")
    account_id: Optional[StrictInt] = Field(default=None, description="Email validator account id.")
    created_at: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="The date time the email was inserted into turboSMTP database after being validated.")
    did_you_mean: Optional[StrictStr] = Field(default=None, description="Suggestive Fix for an email typo")
    id: Optional[StrictInt] = Field(default=None, description="Email Id.")
    list_id: Optional[StrictInt] = Field(default=None, description="List Id.")
    __properties: ClassVar[List[str]] = ["email", "status", "sub_status", "free_email", "domain", "domain_age_days", "smtp_provider", "mx_found", "mx_record", "account_id", "created_at", "did_you_mean", "id", "list_id"]

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['valid', 'invalid', 'catch-all', 'unknown', 'spamtrap', 'abuse', 'do_not_mail']):
            raise ValueError("must be one of enum values ('valid', 'invalid', 'catch-all', 'unknown', 'spamtrap', 'abuse', 'do_not_mail')")
        return value

    @field_validator('sub_status')
    def sub_status_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['', 'antispam_system', 'greylisted', 'mail_server_temporary_error', 'forcible_disconnect', 'mail_server_did_not_respond', 'timeout_exceeded', 'failed_smtp_connection', 'mailbox_quota_exceeded', 'exception_occurred', 'possible_trap', 'role_based', 'global_suppression', 'mailbox_not_found', 'no_dns_entries', 'failed_syntax_check', 'possible_typo', 'unroutable_ip_address', 'leading_period_removed', 'does_not_accept_mail', 'alias_address', 'role_based_catch_all', 'disposable', 'toxic']):
            raise ValueError("must be one of enum values ('', 'antispam_system', 'greylisted', 'mail_server_temporary_error', 'forcible_disconnect', 'mail_server_did_not_respond', 'timeout_exceeded', 'failed_smtp_connection', 'mailbox_quota_exceeded', 'exception_occurred', 'possible_trap', 'role_based', 'global_suppression', 'mailbox_not_found', 'no_dns_entries', 'failed_syntax_check', 'possible_typo', 'unroutable_ip_address', 'leading_period_removed', 'does_not_accept_mail', 'alias_address', 'role_based_catch_all', 'disposable', 'toxic')")
        return value

    @field_validator('created_at')
    def created_at_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})", value):
            raise ValueError(r"must validate the regular expression /(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})/")
        return value

    model_config = {
        "populate_by_name": True,
        "validate_assignment": True,
        "protected_namespaces": (),
    }


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of EmailValidatorListEmailDetails from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # set to None if domain_age_days (nullable) is None
        # and model_fields_set contains the field
        if self.domain_age_days is None and "domain_age_days" in self.model_fields_set:
            _dict['domain_age_days'] = None

        # set to None if smtp_provider (nullable) is None
        # and model_fields_set contains the field
        if self.smtp_provider is None and "smtp_provider" in self.model_fields_set:
            _dict['smtp_provider'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of EmailValidatorListEmailDetails from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "email": obj.get("email"),
            "status": obj.get("status"),
            "sub_status": obj.get("sub_status"),
            "free_email": obj.get("free_email"),
            "domain": obj.get("domain"),
            "domain_age_days": obj.get("domain_age_days"),
            "smtp_provider": obj.get("smtp_provider"),
            "mx_found": obj.get("mx_found"),
            "mx_record": obj.get("mx_record"),
            "account_id": obj.get("account_id"),
            "created_at": obj.get("created_at"),
            "did_you_mean": obj.get("did_you_mean"),
            "id": obj.get("id"),
            "list_id": obj.get("list_id")
        })
        return _obj


